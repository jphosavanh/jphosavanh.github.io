[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Johnson Phosavanh",
    "section": "",
    "text": "I am final year PhD candidate at the Discipline of Business Analytics at the University of Sydney, supervised by Professor Daniel Oron and Dr Nam Ho-Nguyen. My research area is combinatorial optimization with a particular focus on scheduling theory and optimization with graphs."
  },
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Johnson Phosavanh",
    "section": "",
    "text": "I am final year PhD candidate at the Discipline of Business Analytics at the University of Sydney, supervised by Professor Daniel Oron and Dr Nam Ho-Nguyen. My research area is combinatorial optimization with a particular focus on scheduling theory and optimization with graphs."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Johnson Phosavanh",
    "section": "Education",
    "text": "Education\nDoctor of Philosophy (Business)  The University of Sydney Jul 2022 — Dec 2025\n\nThesis title: Dynamic scheduling problems.\n\nBachelor of Advanced Studies (Honours)  The University of Sydney Feb 2021 — Dec 2021\n\nFirst Class Honours with University Medal.\nHonours in Business Analytics.\n\nBachelor of Science  The University of Sydney Feb 2018 — Dec 2020\n\nMajors in Business Analytics and Data Science."
  },
  {
    "objectID": "index.html#research",
    "href": "index.html#research",
    "title": "Johnson Phosavanh",
    "section": "Research",
    "text": "Research\n\nPeer reviewed articles\n\nPhosavanh J., Matsypura, D. (2025). Centrality of shortest paths: algorithms and complexity results. To appear in the INFORMS Journal on Computing.\n\n\n\nAbstract\n\n\n\n\nThe centrality of a node is often used to measure its importance to the structure of a network. Some centrality measures can be extended to measure the importance of a path. In this paper, we consider the problem of finding the most central shortest path. We show that the computational complexity of this problem depends on the measure of centrality used and, in the case of degree centrality, whether the network is weighted or not. We develop a polynomial algorithm for the most degree-central shortest path problem with the worst-case running time of \\(O(|E||V|^2\\Delta(G))\\), where \\(|V|\\) is the number of vertices in the network, \\(|E|\\) is the number of edges in the network, and \\(\\Delta(G)\\) is the maximum degree of the graph. In addition, we show that the same problem is NP-hard on a weighted graph. Furthermore, we show that the problem of finding the most betweenness-central shortest path is solvable in polynomial time, while finding the most closeness-central shortest path is NP-hard, regardless of whether the graph is weighted or not. We also develop an algorithm for finding the most betweenness-central shortest path with a running time of \\(O(|E|^2|V|^2)\\) on both weighted and unweighted graphs. To conclude our paper, we conduct a numerical study of our algorithms on synthetic and real-world networks and compare our results to the existing literature.\n\n\n\nPhosavanh J., Oron, D. (2025). Single-machine two-agent scheduling with a rate-modifying activity and weighted due-date-related functions. Journal of Scheduling. 10.1007/s10951-025-00853-0.\n\n\n\nAbstract\n\n\nBibTeX\n\n\n\n\nWe analyze two-agent scheduling problems with weighted due-date-related scheduling criteria and an optional rate-modifying activity that, when completed, allows jobs to be completed faster. We start with the single-agent problem of minimizing the total weighted late work and then extend the results over to two-agent problems involving combinations of the weighted number of late jobs and the total weighted late work. We examine the properties of optimal schedules and provide efficient pseudo-polynomial time algorithms to solve these problems.\n\n\n\n@article{PhosavanhOron2025JoSH,\ntitle = {Single-machine two-agent scheduling with a rate-modifying activity and weighted due-date-related functions},\njournal = {Journal of Scheduling},\nyear = {2025},\ndoi = {10.1007/s10951-025-00853-0},\nauthor = {Johnson Phosavanh and Daniel Oron},\nkeywords = {Two-agent scheduling, Single-machine, Rate-modifying activity, Dynamic programming},\n}\n\n\nPhosavanh J., Oron, D. (2025). Minimizing the number of late jobs and total late work with step-learning. European Journal of Operational Research, 321(3), 734–749. https://doi.org/10.1016/j.ejor.2024.09.042.\n\n\n\nAbstract\n\n\nBibTeX\n\n\n\n\nWe study single-machine scheduling problems with step-learning, where an improvement in processing time is experienced if a job is started at, or after, a job-dependent learning-date. We consider minimizing two functions: the number of late jobs and the total late work, and we show that when at least a common due-date or common learning-date is assumed, the problem is \\(\\mathcal{NP}\\)-hard in the ordinary sense; however, when both are arbitrary, the problem becomes strongly \\(\\mathcal{NP}\\)-hard. For each of the problems where at least one of the dates is assumed to be common, we analyze the structure of an optimal job schedule with and without idle time and propose pseudo-polynomial time dynamic programming algorithms. We also show that the problem of minimizing the weighted number of late jobs with step-learning can be solved with a minor change to the algorithms for the unweighted case. In addition to this, we show that when a common due-date is assumed and no idle time is allowed, the problem of minimizing the total late work is equivalent to that of minimizing the makespan. Furthermore, we provide a more efficient algorithm to solve the problem of minimizing makespan under the assumption of a common learning-date than the one in the existing literature. Lastly, we show that our analysis can also be applied to the case of step-deterioration, where instead, the processing times of jobs increase at a given date.\n\n\n\n\n@article{PhosavanhOron2025EJOR,\ntitle = {Minimizing the number of late jobs and total late work with step-learning},\njournal = {European Journal of Operational Research},\nyear = {2025},\nissn = {0377-2217},\nvolume = {321},\nnumber = {3},\npages = {734-749},\ndoi = {10.1016/j.ejor.2024.09.042},\nauthor = {Johnson Phosavanh and Daniel Oron},\nkeywords = {Scheduling, Single-machine, Step-learning, Dynamic programming},\n}\n\n\nPhosavanh J., Oron, D. (2024). Two-agent single-machine scheduling with a rate-modifying activity. European Journal of Operational Research, 312(3), 866–876. http://doi.org/10.1016/j.ejor.2023.08.002.\n\n\n\nAbstract\n\n\nBibTeX\n\n\n\n\nWe study single-machine scheduling problems involving a rate-modifying activity and two competing agents with due-date-related functions. Classical scheduling models assume that job processing times remain constant over time; however, in real-world settings, processing times may change due to factors such as technological upgrades or machine maintenance. We complement this with the notion of multiple independent agents competing over the use of a shared resource, each with their own motives. These considerations allow us to model the upcoming trend of the sharing economy, where resources are shared amongst independent competitors in the market. We aim to model these scenarios by considering a variety of scheduling criteria for each agent, including the makespan, the number of late jobs, and the total late work. To account for the change in processing times, we consider an optional rate-modifying activity that once completed, results in a reduction in subsequent job processing times. We show that problems involving the total late work are binary \\(\\mathcal{NP}\\)-hard and propose efficient pseudo-polynomial dynamic programming algorithms for solving these problems. We also show that the remaining problems are solvable in polynomial time.\n\n\n\n\n@article{PhosavanhOron2024,\ntitle = {Two-agent single-machine scheduling with a rate-modifying activity},\njournal = {European Journal of Operational Research},\nyear = {2024},\nvolume = {312},\npages = {866-876},\nnumber = {3},\nissn = {0377-2217},\ndoi = {10.1016/j.ejor.2023.08.002},\nauthor = {Johnson Phosavanh and Daniel Oron},\nkeywords = {Scheduling, Single machine, Two-agents, Dynamic programming},\n}\n\n\n\n\n\nArticles under review\n\nPhosavanh J., Oron, D. (2025). Minimizing total weighted late work with step-learning on a single machine. Submitted to Discrete Applied Mathematics (1st round R&R).\n\n\n\nAbstract\n\n\n\n\nWe study single-machine scheduling problems with step-learning to minimize the total weighted late work. Step-learning is a mechanism that allows jobs to be completed more efficiently if started after a job-dependent learning-date. We show that this problem is strongly \\(\\mathcal{NP}\\)-hard when both learning-dates and due-dates are arbitrary, but when at least one is assumed to be the same for all jobs, the problem is \\(\\mathcal{NP}\\)-hard in the ordinary sense, and we provide pseudo-polynomial algorithms for these cases.\n\n\n\n\n\n\nConferences\n\nPhosavanh J., Oron, D. (2025, June 22 – 25). Single-machine scheduling with cooperative agents and nondisjoint job sets. 34th European Conference on Operational Research (EURO 2025), Leeds, United Kingdom.\nPhosavanh J., Oron, D. (2024, December 4 – 6). Minimizing the number of late jobs and total late work with step-learning. Workshop on Optimisation, Metric Bounds, Approximation and Transversality (WOMBAT), Sydney, NSW, Australia.\nPhosavanh J., Oron, D. (2024, October 20 – 23). Minimizing the number of late jobs and total late work with step-learning. 2024 INFORMS Annual Meeting, Seattle, WA, United States of America.\nPhosavanh J., Oron, D. (2024, June 30 – July 3). Minimizing the number of late jobs and total late work with step-learning. 33rd European Conference on Operational Research (EURO 2024), Copenhagen, Denmark.\nPhosavanh J., Matsypura, D. (2023, December 11 – 16). Finding the most central shortest path in a graph. Joint Workshop on Optimisation, Metric Bounds, Approximation and Transversality (WOMBAT) and Workshop on the Intersections of Computation and Optimisation (WICO), Sydney, NSW, Australia.\nPhosavanh J., Matsypura, D. (2023, October 15 – 18). Finding the most central shortest path in a graph. 2023 INFORMS Annual Meeting, Phoenix, AZ, United States of America.\nPhosavanh J., Oron, D. (2023, June 5 – 6). Single-machine scheduling with two competing agents and rate-modifying activities with weighted due-date related functions. The Fourth International Workshop on Dynamic Scheduling Problems (IWDSP 2023), Winterthur, Switzerland.\nPhosavanh J., Oron, D. (2022, December 6 – 9). Two-agent single-machine scheduling with a rate-modifying activity. 66th Annual Meeting of the Australian Mathematical Society (AustMS), Sydney, NSW, Australia."
  },
  {
    "objectID": "index.html#teaching",
    "href": "index.html#teaching",
    "title": "Johnson Phosavanh",
    "section": "Teaching",
    "text": "Teaching\nThe University of Sydney\n\nQBUS1040: Foundations of Business Analytics\n\nCoordinator & Lecturer: Semester 1, 2025 – Semester 2, 2025\nHead tutor: Semester 1, 2022 – Semester 2, 2024\nTutor: Semester 2, 2021\nLab demonstrator: Semester 1, 2019 – Semester 1, 2021\n\nQBUS2310: Management Science\n\nHead tutor: Semester 1, 2022 – Semester 2, 2024\n\nQBUS6820: Prescriptive Analytics: From Data to Decision\n\nHead tutor: Semester 1, 2023\n\nDATA1001: Foundations of Data Science\n\nLab demonstrator: Semester 1, 2020 – Semester 2, 2020\n\nMATH1005: Statistical Thinking with Data\n\nLab demonstrator: Semester 2, 2020"
  },
  {
    "objectID": "index.html#scholarships-awards",
    "href": "index.html#scholarships-awards",
    "title": "Johnson Phosavanh",
    "section": "Scholarships & Awards",
    "text": "Scholarships & Awards\n\nResearch\n\nEnhanced Business School Research Scholarship, 2022 – 2025.\nPostgraduate Research Support Scheme, 2025.\nDiscipline of Business Analytics Student Paper Prize Winner, 2024.\nPostgraduate Research Support Scheme, 2024.\nResearch Travel Support Scheme, 2024.\nResearch Travel Support Scheme, 2023.\nThe Westbrook and Jessie Anstice Honours Scholarship in Business, 2021.\nDenison Research Scholarship, 2019 – 2020.\n\n\n\nTeaching\n\n2024 Dean’s Award for Feedback for Teaching (FFT).\n\nAwarded in recognition of outstanding performance tof an individual instructor demonstrating and reflecting upon exceptional teaching.\n\nFeedback for Teaching (FFT) Student Survey Award for Teaching.\n\nAwarded in recognition of individual instructors based on high overall evaluations from students on the FFT:\n\nQBUS1040, Semester 1, 2024.\nQBUS2310, Semester 1, 2024.\nQBUS1040, Semester 2, 2023.\n\n\n2022 Discipline of Business Analytics Teaching Excellence Award.\n\nAwarded in recognition of outstanding achievement in teaching within the Discipline of Business Analytics.\n\n\n\n\nAcademic\n\nUniversity of Sydney Academic Merit Prize, 2021.\nDean’s List of Excellence in Academic Performance, 2021.\nUniversity of Sydney Academic Merit Prize, 2020.\nDean’s List of Excellence in Academic Performance, 2020.\nUniversity of Sydney Academic Merit Prize, 2019.\nDiscipline of Business Analytics Prize in 2nd year Quantitative Business: 2019.\nTim Brown Prize No 1 for Intermediate Statistics, 2019.\nDean’s List of Excellence in Academic Performance, 2019.\nDean’s List of Excellence in Academic Performance, 2018."
  },
  {
    "objectID": "teaching-visualisations/lighting-problem.html",
    "href": "teaching-visualisations/lighting-problem.html",
    "title": "VMLS: Lighting problem",
    "section": "",
    "text": "#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 480\n\nfrom shiny import App, render, ui, reactive\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef get_pattern(power, weights):\n    return np.array([power[i] * weights[i] for i in range(len(power))]).sum(axis=0).reshape(power.shape[1:3])\n\ndef rms_error(pattern):\n    return np.linalg.norm(pattern - np.ones(m * m)) / m\n\nm = 25\nn = 10\nlamps = {\n    1: [ 4.13, 4.63, 4.0],\n    2: [14.11, 3.72, 3.5],\n    3: [22.60, 7.92, 6.0],\n    4: [5.53, 12.71, 4.0],\n    5: [12.21, 15.30, 4.0],\n    6: [15.31, 11.21, 6.0],\n    7: [21.30, 14.50, 5.5],\n    8: [3.93, 21.69, 5.0],\n    9: [13.12, 20.69, 5.0],\n    10: [20.30, 20.79, 4.5]\n    }\n\nx = [loc[0] for loc in lamps.values()]\ny = [loc[1] for loc in lamps.values()]\n\npower = np.zeros((n, m, m))\n\nfor i in range(m):\n    for j in range(m):\n        for l in lamps:\n            power[l - 1, i, j] = 1 / np.linalg.norm(np.array([i - 0.5, j + 0.5, 0]) - np.array(lamps[l]))**2\n\npower = power / power.sum(axis=0).mean()\n\nA = np.array([power[i].reshape(m * m) for i in range(n)]).T\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_radio_buttons(  \n                'power',  \n                'Lighting strategy',\n                {'0s': 'Use 0s vector', \n                'ls': 'Use least squares',\n                '1s': 'Use 1s vector',\n                '1': 'Turn light 1 on only',\n                '110': 'Turn lights 1 and 10 on only',\n                'corners': 'Turn corner lights',\n                '1-opt': 'Turn light 1 on only (optimally)',\n                '110-opt': 'Turn lights 1 and 10 on only (optimally)',\n                'corners-opt': 'Turn corner lights (optimally)'},\n                selected='0s'\n            )  \n        ),\n        ui.layout_columns(\n        ui.output_plot(\"mainplot\"),\n        ui.card(\n            ui.output_plot(\"histplot\", height=\"45%\"),\n            ui.output_plot(\"powerplot\", height=\"45%\"),\n            ui.output_text_verbatim(\"RMS\"), \n        ),\n        ),\n    ),\n)\n\n\ndef server(input, output, session):\n\n    @reactive.calc\n    def pattern():\n        if input.power() == '0s':\n            p = np.zeros(n)\n        elif input.power() == '1s':\n            p = np.ones(n)\n        elif input.power() == '1':\n            p = np.zeros(n)\n            p[0] = 1\n        elif input.power() == '110':\n            p = np.zeros(n)\n            p[0] = 1\n            p[9] = 1\n        elif input.power() == 'corners':\n            p = np.zeros(n)\n            p[0] = 1\n            p[2] = 1\n            p[7] = 1\n            p[9] = 1\n        elif input.power() == 'ls':\n            p = np.linalg.pinv(A) @ np.ones(m * m)\n        elif input.power() == '1-opt':\n            p = np.zeros(n)\n            p[0] = np.linalg.pinv(A[:, [0]]) @ np.ones(m * m)\n        elif input.power() == '110-opt':\n            theta = np.linalg.pinv(A[:, [0, 9]]) @ np.ones(m * m)\n            p = np.zeros(n)\n            p[0] = theta[0]\n            p[9] = theta[1]\n        elif input.power() == 'corners-opt':\n            theta = np.linalg.pinv(A[:, [0, 2, 7, 9]]) @ np.ones(m * m)\n            p = np.zeros(n)\n            p[0] = theta[0]\n            p[2] = theta[1]\n            p[7] = theta[2]\n            p[9] = theta[3]\n        return get_pattern(power, p), p\n\n    # ========================================================================\n\n    @render.plot\n    def mainplot():\n        fig, ax = plt.subplots()\n        im = ax.imshow(pattern()[0], cmap='grey', vmin=0, vmax=3)\n        plt.colorbar(im, ax=ax)\n        ax.axis('off')\n        plt.scatter(x, y, c='red')\n        for i, loc in lamps.items():\n            ax.annotate(f'{i}: ({loc[2]:.1f}m)', (loc[0] - 0.35, loc[1] - 0.45), c='red')\n        return fig\n\n    # ========================================================================\n\n    @render.plot\n    def histplot():\n        fig, ax = plt.subplots()\n        ax.hist(pattern()[0].reshape(m * m), bins=50)\n        ax.set_xlim(0, 2)\n        ax.set_yticks([])\n        ax.set_title('Histogram of luminosity')\n        return fig\n\n    # ========================================================================\n\n    @render.plot\n    def powerplot():\n        fig, ax = plt.subplots()\n        ax.bar([i + 1 for i in range(n)], pattern()[1])\n        ax.set_xticks([i + 1 for i in range(n)])\n        ax.set_ylim(0, max(3, np.ceil(np.max(pattern()[1]))))\n        ax.set_title('Lamp powers')\n        return \n\n    # ========================================================================\n\n    @render.text\n    def RMS():\n        return f'The RMS error is {rms_error(pattern()[0].reshape(m * m)) :.2f}.'\n\n    # ========================================================================\n\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "teaching-visualisations/least-squares.html",
    "href": "teaching-visualisations/least-squares.html",
    "title": "VMLS: Least squares",
    "section": "",
    "text": "#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 600\n\nfrom shiny import App, render, ui, reactive\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport plotly.graph_objects as go\nfrom shinywidgets import render_widget, output_widget\n\ndef Z_func(x, y):\n    return (2*x - 1)**2 + (-x + y)**2 + (2*y + 1)**2\n\napp_ui = ui.page_fluid(\n    ui.layout_columns(\n        output_widget('curve'),\n        output_widget('contourplot')\n    ),\n)\n\n\ndef server(input, output, session):\n\n    @render_widget\n    def curve():\n\n        X_lin  = np.arange(-1, 1.5, 0.05)\n        Y_lin = np.arange(-1.5, 1, 0.05)\n        X, Y = np.meshgrid(X_lin, Y_lin)\n        Z = Z_func(X, Y)\n\n        fig = go.Figure(data=[go.Surface(x=X, y=Y, z=Z, name='Curve', colorscale='Turbo')])\n        \n        fig = fig.update_layout(\n            autosize=True,\n            height=600,\n            margin=dict(l=65, r=50, b=65, t=90),\n            scene = dict(xaxis = dict(range=[-1, 1.5], title=dict(text='x_1')),\n                        yaxis = dict(range=[-1.5, 1], title=dict(text='x_2')),\n                        zaxis = dict(range=[np.min(Z) - (np.max(Z) - np.min(Z)) * 0.05, np.max(Z) + (np.max(Z) - np.min(Z)) * 0.05], title=dict(text=''))\n                        )\n            )\n        return fig\n\n    # ========================================================================\n\n    @render_widget\n    def contourplot():\n        X_lin  = np.arange(-1, 1.5, 0.05)\n        Y_lin = np.arange(-1.5, 1, 0.05)\n        X, Y = np.meshgrid(X_lin, Y_lin)\n        Z = Z_func(X, Y)\n\n        fig = go.Figure(data =\n            [go.Contour(\n                z=Z,\n                x=X_lin,\n                y=Y_lin, \n                colorscale='Turbo',\n                contours=dict(\n                start=0.666666,\n                end=22.666666,\n                size=1,\n            ),\n            )])\n\n        fig = fig.update_layout(\n            autosize=True,\n            height=600,\n            margin=dict(l=65, r=50, b=65, t=90),\n            scene = dict(xaxis = dict(range=[-1, 1.5], title=dict(text='x_1')),\n                        yaxis = dict(range=[-1.5, 1], title=dict(text='x_2')),\n                        zaxis = dict(range=[np.min(Z) - (np.max(Z) - np.min(Z)) * 0.05, np.max(Z) + (np.max(Z) - np.min(Z)) * 0.05], title=dict(text=''))\n                        )\n            )\n        return fig\n\n    # ========================================================================\n\n\napp = App(app_ui, server)"
  }
]